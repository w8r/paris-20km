{"version":3,"sources":["node_modules/@turf/helpers/index.js","node_modules/@turf/invariant/index.js","node_modules/@turf/destination/index.js","node_modules/@turf/circle/index.js","index.js"],"names":["args","location","search","replace","split","reduce","o","param","keyvalue","mapboxgl","accessToken","access_token","localStorage","mapEl","document","getElementById","map","Map","container","style","center","zoom","layers","on","addSource","type","data","features","forEach","layer","i","addLayer","source","paint","marker","e","classList","add","intervals","Array","from","querySelectorAll","el","value","profile","querySelector","console","log","coords","lngLat","lng","lat","remove","Marker","setLngLat","addTo","getSource","setData","fill","_","params","radius","cellSize","concavity","lengthThreshold","url","URL","origin","Object","keys","key","searchParams","append","length","interval","groupCollapsed","time","fetch","then","response","json","timeEnd","groupEnd","catch","error","popup","Popup","closeButton","closeOnClick"],"mappings":"AGAA,ADAA,AFAA,ACAA;AECA,ADAA,AFAA,ACAA;AGDA,ADEA,ADAA,AFAA,ACAA;AECA,ADAA,AFAA,ACAA;AECA,ADAA,AFAA,ACAA;AECA,ADAA,AFAA,ACAA;AGJA,ADKA,ADAA,AFAA,ACAA;AGJA,ADKA,ADAA,AFAA,ACAA;AGHA,ADIA,ADAA,AFAA,ACAA,MGJMA,IAAI,GAAGC,QAAQ,CAACC,MAAT,CAAgBC,OAAhB,CAAwB,KAAxB,EAA+B,EAA/B,EAAmCC,KAAnC,CAAyC,GAAzC,EAA8CC,MAA9C,CAAqD,UAAUC,CAAV,EAAaC,KAAb,EAAoB;AACpF,ADIF,ADAA,AFAA,ACAA,MGJMC,QAAQ,GAAGD,KAAK,CAACH,KAAN,CAAY,GAAZ,CAAf;AACAE,ADIF,ADAA,AFAA,ACAA,EGJEA,CAAC,CAACE,QAAQ,CAAC,CAAD,CAAT,CAAD,GAAiBA,QAAQ,CAAC,CAAD,CAAzB;AACA,ADIF,ADAA,AFAA,ACAA,SGJSF,CAAP;AACD,ADID,ADAA,AFAA,ACAA,CGRa,EAIV,EAJU,CAAb;AAMAG,ADGA,ADAA,AFAA,ACAA,QGHQ,CAACC,WAAT,GAAuBV,IAAI,CAACW,YAAL,IAAqBC,YAAY,CAACF,WAAzD;AACA,ADGA,ADAA,AFAA,ACAA,MGHMG,KAAK,GAAGC,QAAQ,CAACC,cAAT,CAAwB,KAAxB,CAAd;AAEA,ADEA,ADAA,AFAA,ACAA,MGFMC,GAAG,GAAG,IAAIP,QAAQ,CAACQ,GAAb,CAAiB;AAC3BC,ADEF,ADAA,AFAA,ACAA,EGFEA,SAAS,EAAEL,KADgB;AAE3BM,ADEF,ADAA,AFAA,ACAA,EGFEA,KAAK,EAAE,iCAFoB;AAG3BC,ADEF,ADAA,AFAA,ACAA,EGFEA,MAAM,EAAE,CAAC,QAAD,EAAW,SAAX,CAHmB;AAI3BC,ADEF,ADAA,AFAA,ACAA,EGFEA,IAAI,EAAE;AAJqB,ADO7B,ADAA,AFAA,ACAA,CGPY,CAAZ;AAOA,ADCA,ADAA,AFAA,ACAA,MGDMC,MAAM,GAAG,CACb,CAAC,EAAD,EAAK,SAAL,EAAgB,GAAhB,CADa,EAEb,CAAC,EAAD,EAAK,SAAL,EAAgB,GAAhB,CAFa,EAGb,CAAC,EAAD,EAAK,SAAL,EAAgB,GAAhB,CAHa,CAAf;AAMAN,ADJA,ADAA,AFAA,ACAA,GGIG,CAACO,EAAJ,CAAO,MAAP,EAAe,YAAY;AACzBP,ADJF,ADAA,AFAA,ACAA,EGIEA,GAAG,CAACQ,SAAJ,CAAc,MAAd,EAAsB;AACpBC,ADJJ,ADAA,AFAA,ACAA,IGIIA,IAAI,EAAE,SADc;AAEpBC,ADJJ,ADAA,AFAA,ACAA,IGIIA,IAAI,EAAE;AACJD,ADJN,ADAA,AFAA,ACAA,MGIMA,IAAI,EAAE,mBADF;AAEJE,ADJN,ADAA,AFAA,ACAA,MGIMA,QAAQ,EAAE;AAFN,ADDV,ADAA,AFAA,ACAA;AGDwB,ADExB,ADAA,AFAA,ACAA,GGFE;AAOAX,ADJF,ADAA,AFAA,ACAA,EGIEA,GAAG,CAACQ,SAAJ,CAAc,QAAd,EAAwB;AACtB,ADJJ,ADAA,AFAA,ACAA,YGIY,SADc;AAEtBE,ADJJ,ADAA,AFAA,ACAA,IGIIA,IAAI,EAAE;AACJD,ADJN,ADAA,AFAA,ACAA,MGIMA,IAAI,EAAE,mBADF;AAEJE,ADJN,ADAA,AFAA,ACAA,MGIMA,QAAQ,EAAE;AAFN,ADDV,ADAA,AFAA,ACAA;AGD0B,ADE1B,ADAA,AFAA,ACAA,GGFE;AAQAL,ADLF,ADAA,AFAA,ACAA,EGKEA,MAAM,CAACM,OAAP,CAAe,UAAUC,KAAV,EAAiBC,CAAjB,EAAoB;AACjCd,ADLJ,ADAA,AFAA,ACAA,IGKIA,GAAG,CAACe,QAAJ,CAAa;AACX,AFLN,AFAA,ACAA,YGKY,UAAUD,CADL;AAEX,AFLN,AFAA,ACAA,cGKc,MAFG;AAGX,AFLN,AFAA,ACAA,gBGKgB,MAHC;AAIX,AFLN,AFAA,ACAA,gBGKgB,EAJC;AAKX,AFLN,AFAA,ACAA,eGKe;AACP,AFLR,AFAA,ACAA,sBGKsBD,KAAK,CAAC,CAAD,CADZ;AAEP,AFLR,AFAA,ACAA,wBGKwBA,KAAK,CAAC,CAAD;AAFd,AFFf,AFAA,ACAA,OGHiB;AASX,AFLN,AFAA,ACAA,gBGKgB,CACR,KADQ,EAER,CAAC,IAAD,EAAO,OAAP,EAAgB,SAAhB,CAFQ,EAGR,CAAC,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AJ9BA,ACAA;AG+BA,AJ9BA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA,ACAA;ADCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"paris-distance.e31bb0bc.js","sourceRoot":"..","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexports.earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.factors = {\n    centimeters: exports.earthRadius * 100,\n    centimetres: exports.earthRadius * 100,\n    degrees: exports.earthRadius / 111325,\n    feet: exports.earthRadius * 3.28084,\n    inches: exports.earthRadius * 39.370,\n    kilometers: exports.earthRadius / 1000,\n    kilometres: exports.earthRadius / 1000,\n    meters: exports.earthRadius,\n    metres: exports.earthRadius,\n    miles: exports.earthRadius / 1609.344,\n    millimeters: exports.earthRadius * 1000,\n    millimetres: exports.earthRadius * 1000,\n    nauticalmiles: exports.earthRadius / 1852,\n    radians: 1,\n    yards: exports.earthRadius / 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.370,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / exports.earthRadius,\n    yards: 1 / 1.0936,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexports.areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nfunction feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\nexports.feature = feature;\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nfunction geometry(type, coordinates, options) {\n    if (options === void 0) { options = {}; }\n    switch (type) {\n        case \"Point\": return point(coordinates).geometry;\n        case \"LineString\": return lineString(coordinates).geometry;\n        case \"Polygon\": return polygon(coordinates).geometry;\n        case \"MultiPoint\": return multiPoint(coordinates).geometry;\n        case \"MultiLineString\": return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\": return multiPolygon(coordinates).geometry;\n        default: throw new Error(type + \" is invalid\");\n    }\n}\nexports.geometry = geometry;\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nfunction point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.point = point;\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nfunction points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\nexports.points = points;\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nfunction polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.polygon = polygon;\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nfunction polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\nexports.polygons = polygons;\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nfunction lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.lineString = lineString;\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nfunction lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\nexports.lineStrings = lineStrings;\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nfunction featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\nexports.featureCollection = featureCollection;\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nfunction multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiLineString = multiLineString;\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nfunction multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPoint = multiPoint;\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nfunction multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\nexports.multiPolygon = multiPolygon;\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nfunction geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\nexports.geometryCollection = geometryCollection;\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nfunction round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\nexports.round = round;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nfunction radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\nexports.radiansToLength = radiansToLength;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nfunction lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = exports.factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\nexports.lengthToRadians = lengthToRadians;\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, or kilometers inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nfunction lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\nexports.lengthToDegrees = lengthToDegrees;\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nfunction bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\nexports.bearingToAzimuth = bearingToAzimuth;\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nfunction radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return degrees * 180 / Math.PI;\n}\nexports.radiansToDegrees = radiansToDegrees;\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nfunction degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return radians * Math.PI / 180;\n}\nexports.degreesToRadians = degreesToRadians;\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nfunction convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\nexports.convertLength = convertLength;\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted distance\n */\nfunction convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = exports.areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = exports.areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\nexports.convertArea = convertArea;\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nfunction isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num) && !/^\\s*$/.test(num);\n}\nexports.isNumber = isNumber;\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nfunction isObject(input) {\n    return (!!input) && (input.constructor === Object);\n}\nexports.isObject = isObject;\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nfunction validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\nexports.validateBBox = validateBBox;\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nfunction validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\nexports.validateId = validateId;\n// Deprecated methods\nfunction radians2degrees() {\n    throw new Error(\"method has been renamed to `radiansToDegrees`\");\n}\nexports.radians2degrees = radians2degrees;\nfunction degrees2radians() {\n    throw new Error(\"method has been renamed to `degreesToRadians`\");\n}\nexports.degrees2radians = degrees2radians;\nfunction distanceToDegrees() {\n    throw new Error(\"method has been renamed to `lengthToDegrees`\");\n}\nexports.distanceToDegrees = distanceToDegrees;\nfunction distanceToRadians() {\n    throw new Error(\"method has been renamed to `lengthToRadians`\");\n}\nexports.distanceToRadians = distanceToRadians;\nfunction radiansToDistance() {\n    throw new Error(\"method has been renamed to `radiansToLength`\");\n}\nexports.radiansToDistance = radiansToDistance;\nfunction bearingToAngle() {\n    throw new Error(\"method has been renamed to `bearingToAzimuth`\");\n}\nexports.bearingToAngle = bearingToAngle;\nfunction convertDistance() {\n    throw new Error(\"method has been renamed to `convertLength`\");\n}\nexports.convertDistance = convertDistance;\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar helpers_1 = require(\"@turf/helpers\");\r\n/**\r\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\r\n *\r\n * @name getCoord\r\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\r\n * @returns {Array<number>} coordinates\r\n * @example\r\n * var pt = turf.point([10, 10]);\r\n *\r\n * var coord = turf.getCoord(pt);\r\n * //= [10, 10]\r\n */\r\nfunction getCoord(coord) {\r\n    if (!coord) {\r\n        throw new Error(\"coord is required\");\r\n    }\r\n    if (!Array.isArray(coord)) {\r\n        if (coord.type === \"Feature\" && coord.geometry !== null && coord.geometry.type === \"Point\") {\r\n            return coord.geometry.coordinates;\r\n        }\r\n        if (coord.type === \"Point\") {\r\n            return coord.coordinates;\r\n        }\r\n    }\r\n    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {\r\n        return coord;\r\n    }\r\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\r\n}\r\nexports.getCoord = getCoord;\r\n/**\r\n * Unwrap coordinates from a Feature, Geometry Object or an Array\r\n *\r\n * @name getCoords\r\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\r\n * @returns {Array<any>} coordinates\r\n * @example\r\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\r\n *\r\n * var coords = turf.getCoords(poly);\r\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\r\n */\r\nfunction getCoords(coords) {\r\n    if (Array.isArray(coords)) {\r\n        return coords;\r\n    }\r\n    // Feature\r\n    if (coords.type === \"Feature\") {\r\n        if (coords.geometry !== null) {\r\n            return coords.geometry.coordinates;\r\n        }\r\n    }\r\n    else {\r\n        // Geometry\r\n        if (coords.coordinates) {\r\n            return coords.coordinates;\r\n        }\r\n    }\r\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\r\n}\r\nexports.getCoords = getCoords;\r\n/**\r\n * Checks if coordinates contains a number\r\n *\r\n * @name containsNumber\r\n * @param {Array<any>} coordinates GeoJSON Coordinates\r\n * @returns {boolean} true if Array contains a number\r\n */\r\nfunction containsNumber(coordinates) {\r\n    if (coordinates.length > 1 && helpers_1.isNumber(coordinates[0]) && helpers_1.isNumber(coordinates[1])) {\r\n        return true;\r\n    }\r\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\r\n        return containsNumber(coordinates[0]);\r\n    }\r\n    throw new Error(\"coordinates must only contain numbers\");\r\n}\r\nexports.containsNumber = containsNumber;\r\n/**\r\n * Enforce expectations about types of GeoJSON objects for Turf.\r\n *\r\n * @name geojsonType\r\n * @param {GeoJSON} value any GeoJSON object\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction geojsonType(value, type, name) {\r\n    if (!type || !name) {\r\n        throw new Error(\"type and name required\");\r\n    }\r\n    if (!value || value.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + value.type);\r\n    }\r\n}\r\nexports.geojsonType = geojsonType;\r\n/**\r\n * Enforce expectations about types of {@link Feature} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name featureOf\r\n * @param {Feature} feature a feature with an expected geometry type\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} error if value is not the expected type.\r\n */\r\nfunction featureOf(feature, type, name) {\r\n    if (!feature) {\r\n        throw new Error(\"No feature passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".featureOf() requires a name\");\r\n    }\r\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n    }\r\n    if (!feature.geometry || feature.geometry.type !== type) {\r\n        throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n    }\r\n}\r\nexports.featureOf = featureOf;\r\n/**\r\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\r\n * Internally this uses {@link geojsonType} to judge geometry types.\r\n *\r\n * @name collectionOf\r\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\r\n * @param {string} type expected GeoJSON type\r\n * @param {string} name name of calling function\r\n * @throws {Error} if value is not the expected type.\r\n */\r\nfunction collectionOf(featureCollection, type, name) {\r\n    if (!featureCollection) {\r\n        throw new Error(\"No featureCollection passed\");\r\n    }\r\n    if (!name) {\r\n        throw new Error(\".collectionOf() requires a name\");\r\n    }\r\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\r\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\r\n    }\r\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\r\n        var feature = _a[_i];\r\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\r\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\r\n        }\r\n        if (!feature.geometry || feature.geometry.type !== type) {\r\n            throw new Error(\"Invalid input to \" + name + \": must be a \" + type + \", given \" + feature.geometry.type);\r\n        }\r\n    }\r\n}\r\nexports.collectionOf = collectionOf;\r\n/**\r\n * Get Geometry from Feature or Geometry Object\r\n *\r\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\r\n * @returns {Geometry|null} GeoJSON Geometry Object\r\n * @throws {Error} if geojson is not a Feature or Geometry Object\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getGeom(point)\r\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\r\n */\r\nfunction getGeom(geojson) {\r\n    if (geojson.type === \"Feature\") {\r\n        return geojson.geometry;\r\n    }\r\n    return geojson;\r\n}\r\nexports.getGeom = getGeom;\r\n/**\r\n * Get GeoJSON object's type, Geometry type is prioritize.\r\n *\r\n * @param {GeoJSON} geojson GeoJSON object\r\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\r\n * @returns {string} GeoJSON type\r\n * @example\r\n * var point = {\r\n *   \"type\": \"Feature\",\r\n *   \"properties\": {},\r\n *   \"geometry\": {\r\n *     \"type\": \"Point\",\r\n *     \"coordinates\": [110, 40]\r\n *   }\r\n * }\r\n * var geom = turf.getType(point)\r\n * //=\"Point\"\r\n */\r\nfunction getType(geojson, name) {\r\n    if (geojson.type === \"FeatureCollection\") {\r\n        return \"FeatureCollection\";\r\n    }\r\n    if (geojson.type === \"GeometryCollection\") {\r\n        return \"GeometryCollection\";\r\n    }\r\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\r\n        return geojson.geometry.type;\r\n    }\r\n    return geojson.type;\r\n}\r\nexports.getType = getType;\r\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// http://en.wikipedia.org/wiki/Haversine_formula\n// http://www.movable-type.co.uk/scripts/latlong.html\nvar helpers_1 = require(\"@turf/helpers\");\nvar invariant_1 = require(\"@turf/invariant\");\n/**\n * Takes a {@link Point} and calculates the location of a destination point given a distance in\n * degrees, radians, miles, or kilometers; and bearing in degrees.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name destination\n * @param {Coord} origin starting point\n * @param {number} distance distance from the origin point\n * @param {number} bearing ranging from -180 to 180\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\n * @param {Object} [options.properties={}] Translate properties to Point\n * @returns {Feature<Point>} destination point\n * @example\n * var point = turf.point([-75.343, 39.984]);\n * var distance = 50;\n * var bearing = 90;\n * var options = {units: 'miles'};\n *\n * var destination = turf.destination(point, distance, bearing, options);\n *\n * //addToMap\n * var addToMap = [point, destination]\n * destination.properties['marker-color'] = '#f00';\n * point.properties['marker-color'] = '#0f0';\n */\nfunction destination(origin, distance, bearing, options) {\n    if (options === void 0) { options = {}; }\n    // Handle input\n    var coordinates1 = invariant_1.getCoord(origin);\n    var longitude1 = helpers_1.degreesToRadians(coordinates1[0]);\n    var latitude1 = helpers_1.degreesToRadians(coordinates1[1]);\n    var bearingRad = helpers_1.degreesToRadians(bearing);\n    var radians = helpers_1.lengthToRadians(distance, options.units);\n    // Main\n    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +\n        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));\n    var longitude2 = longitude1 + Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));\n    var lng = helpers_1.radiansToDegrees(longitude2);\n    var lat = helpers_1.radiansToDegrees(latitude2);\n    return helpers_1.point([lng, lat], options.properties);\n}\nexports.default = destination;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar destination_1 = require(\"@turf/destination\");\nvar helpers_1 = require(\"@turf/helpers\");\n/**\n * Takes a {@link Point} and calculates the circle polygon given a radius in degrees, radians, miles, or kilometers; and steps for precision.\n *\n * @name circle\n * @param {Feature<Point>|number[]} center center point\n * @param {number} radius radius of the circle\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.steps=64] number of steps\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\n * @param {Object} [options.properties={}] properties\n * @returns {Feature<Polygon>} circle polygon\n * @example\n * var center = [-75.343, 39.984];\n * var radius = 5;\n * var options = {steps: 10, units: 'kilometers', properties: {foo: 'bar'}};\n * var circle = turf.circle(center, radius, options);\n *\n * //addToMap\n * var addToMap = [turf.point(center), circle]\n */\nfunction circle(center, radius, options) {\n    if (options === void 0) { options = {}; }\n    // default params\n    var steps = options.steps || 64;\n    var properties = options.properties ? options.properties : (!Array.isArray(center) && center.type === 'Feature' && center.properties) ? center.properties : {};\n    // main\n    var coordinates = [];\n    for (var i = 0; i < steps; i++) {\n        coordinates.push(destination_1.default(center, radius, i * -360 / steps, options).geometry.coordinates);\n    }\n    coordinates.push(coordinates[0]);\n    return helpers_1.polygon([coordinates], properties);\n}\nexports.default = circle;\n","import createCircle from '@turf/circle';\n//import mapboxgl from 'mapbox-gl';\n//import mapboxgl from 'mapbox-gl';\n\nconst args = location.search.replace(/^\\?/, '').split('&').reduce(function (o, param) {\n  var keyvalue = param.split('=');\n  o[keyvalue[0]] = keyvalue[1];\n  return o;\n}, {});\n\nmapboxgl.accessToken = args.access_token || localStorage.accessToken;\nconst mapEl = document.getElementById('map');\n\nconst map = new mapboxgl.Map({\n  container: mapEl,\n  style: 'mapbox://styles/mapbox/light-v8',\n  center: [2.326986, 48.857775],\n  zoom: 12\n});\n\nconst layers = [\n  [30, '#00aaFF', 0.1],\n  [20, '#00aaFF', 0.2],\n  [10, '#00aaFF', 0.8],\n];\n\nmap.on('load', function () {\n  map.addSource('grid', {\n    type: 'geojson',\n    data: {\n      type: 'FeatureCollection',\n      features: []\n    }\n  });\n  map.addSource('circle', {\n    'type': 'geojson',\n    data: {\n      type: 'FeatureCollection',\n      features: []\n    }\n  })\n\n  layers.forEach(function (layer, i) {\n    map.addLayer({\n      'id': 'grid-' + i,\n      'type': 'fill',\n      'source': 'grid',\n      'layout': {},\n      'paint': {\n        'fill-color': layer[1],\n        'fill-opacity': layer[2]\n      },\n      'filter': [\n        'all',\n        ['==', '$type', 'Polygon'],\n        ['<=', 'time', layer[0]]\n      ]\n    }, 'road-path');\n  });\n\n  map.addLayer({\n    'id': 'distance',\n    type: 'line',\n    source: 'circle',\n    paint: {\n      'line-color': 'red',\n      'line-width': 1,\n      'line-opacity': 0.25\n    }\n  }, 'road-path');\n});\n\n/** @type {mapboxgl.Marker} */\nlet marker;\nmap.on('click', (e) => {\n  mapEl.classList.add('loading');\n  const intervals = Array.from(\n    document.querySelectorAll('.intervals input[type=\"checkbox\"]:checked')\n  ).map(el => el.value);\n\n  const profile = document.querySelector('input[name=\"profile\"]:checked').value;\n  console.log(profile);\n\n  const coords = [e.lngLat.lng, e.lngLat.lat];\n\n  if (marker) marker.remove();\n  marker = new mapboxgl.Marker()\n    .setLngLat([e.lngLat.lng, e.lngLat.lat])\n    .addTo(map);\n\n  map.getSource('circle').setData({\n    type: 'FeatureCollection',\n    features: Array(19).fill(0).map((_, i) => createCircle(coords, i + 1))\n  });\n\n  const params = {\n    lng: e.lngLat.lng,\n    lat: e.lngLat.lat,\n    radius: document.getElementById('radius').value,\n    cellSize: document.getElementById('cellSize').value,\n    concavity: document.getElementById('concavity').value,\n    lengthThreshold: document.getElementById('lengthThreshold').value,\n  };\n\n  const url = new URL(`${location.origin}/api/${profile}`);\n  Object.keys(params).forEach(key => url.searchParams.append(key, params[key]));\n  (intervals.length > 0 ?\n    intervals :\n    [10, 20, 30]).forEach(interval => url.searchParams.append('intervals', interval));\n\n  console.groupCollapsed(e.lngLat.lng, e.lngLat.lat);\n  console.time('request');\n  fetch(url)\n    .then(response => response.json())\n    .then((data) => {\n      console.log(data);\n      console.timeEnd('request');\n      console.groupEnd();\n      map.getSource('grid').setData(data);\n      mapEl.classList.remove('loading');\n    })\n    .catch((error) => {\n      console.error(error);\n      mapEl.classList.remove('loading');\n    });\n});\n\nvar popup = new mapboxgl.Popup({\n  closeButton: false,\n  closeOnClick: false\n});\n\n// map.on('mousemove', function (e) {\n//   var features = map.queryRenderedFeatures(e.point, {\n//     layers: ['grid-0', 'grid-1', 'grid-2', 'grid-3', 'grid-4', 'grid-5']\n//   });\n\n//   if (!features.length) {\n//     popup.remove();\n//     return;\n//   }\n//   var feature = features[0];\n//   popup.setLngLat(e.lngLat)\n//     .setHTML(feature.properties.time + ' minutes')\n//     .addTo(map);\n// });\n"]}